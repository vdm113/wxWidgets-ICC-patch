/////////////////////////////////////////////////////////////////////////////
// Name:        event.h
// Purpose:     interface of wxEvent-derived classes,
//              see event_base.h for wxEvtHandler and wxEvent.
// Author:      wxWidgets team
// RCS-ID:      $Id$
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////


/**
    @class wxEventBlocker

    This class is a special event handler which allows to discard
    any event (or a set of event types) directed to a specific window.

    Example:

    @code
    void MyWindow::DoSomething()
    {
        {
            // block all events directed to this window while
            // we do the 1000 FunctionWhichSendsEvents() calls
            wxEventBlocker blocker(this);

            for ( int i = 0; i  1000; i++ )
                FunctionWhichSendsEvents(i);

        } // ~wxEventBlocker called, old event handler is restored

        // the event generated by this call will be processed:
        FunctionWhichSendsEvents(0)
    }
    @endcode

    @library{wxcore}
    @category{events}

    @see @ref overview_events_processing, wxEvtHandler
*/
class wxEventBlocker : public wxEvtHandler
{
public:
    /**
        Constructs the blocker for the given window and for the given event type.

        If @a type is @c wxEVT_ANY, then all events for that window are blocked.
        You can call Block() after creation to add other event types to the list
        of events to block.

        Note that the @a win window @b must remain alive until the
        wxEventBlocker object destruction.
    */
    wxEventBlocker(wxWindow* win, wxEventType type = -1);

    /**
        Destructor. The blocker will remove itself from the chain of event handlers for
        the window provided in the constructor, thus restoring normal processing of events.
    */
    virtual ~wxEventBlocker();

    /**
        Adds to the list of event types which should be blocked the given @a eventType.
    */
    void Block(wxEventType eventType);
};



/**
   Helper class to temporarily change an event to not propagate.
*/
class wxPropagationDisabler
{
public:
    wxPropagationDisabler(wxEvent& event);
    ~wxPropagationDisabler();
};


/**
   Helper class to temporarily lower propagation level.
*/
class wxPropagateOnce
{
public:
    wxPropagateOnce(wxEvent& event);
    ~wxPropagateOnce();
};



/**
    Flags for categories of keys.

    These values are used by wxKeyEvent::IsKeyInCategory(). They may be
    combined via the bitwise operators |, &, and ~.

    @since 2.9.1
*/
enum wxKeyCategoryFlags
{
    /// arrow keys, on and off numeric keypads
    WXK_CATEGORY_ARROW,

    /// page up and page down keys, on and off numeric keypads
    WXK_CATEGORY_PAGING,

    /// home and end keys, on and off numeric keypads
    WXK_CATEGORY_JUMP,

    /// tab key, on and off numeric keypads
    WXK_CATEGORY_TAB,

    /// backspace and delete keys, on and off numeric keypads
    WXK_CATEGORY_CUT,

    /// union of WXK_CATEGORY_ARROW, WXK_CATEGORY_PAGING, and WXK_CATEGORY_JUMP categories
    WXK_CATEGORY_NAVIGATION
};


/**
    @class wxKeyEvent

    This event class contains information about key press and release events.

    The main information carried by this event is the key being pressed or
    released. It can be accessed using either GetKeyCode() function or
    GetUnicodeKey(). For the printable characters, the latter should be used as
    it works for any keys, including non-Latin-1 characters that can be entered
    when using national keyboard layouts. GetKeyCode() should be used to handle
    special characters (such as cursor arrows keys or @c HOME or @c INS and so
    on) which correspond to ::wxKeyCode enum elements above the @c WXK_START
    constant. While GetKeyCode() also returns the character code for Latin-1
    keys for compatibility, it doesn't work for Unicode characters in general
    and will return @c WXK_NONE for any non-Latin-1 ones. For this reason, it's
    recommended to always use GetUnicodeKey() and only fall back to GetKeyCode()
    if GetUnicodeKey() returned @c WXK_NONE meaning that the event corresponds
    to a non-printable special keys.

    While both of these functions can be used with the events of @c
    wxEVT_KEY_DOWN, @c wxEVT_KEY_UP and @c wxEVT_CHAR types, the values
    returned by them are different for the first two events and the last one.
    For the latter, the key returned corresponds to the character that would
    appear in e.g. a text zone if the user pressed the key in it. As such, its
    value depends on the current state of the Shift key and, for the letters,
    on the state of Caps Lock modifier. For example, if @c A key is pressed
    without Shift being held down, wxKeyEvent of type @c wxEVT_CHAR generated
    for this key press will return (from either GetKeyCode() or GetUnicodeKey()
    as their meanings coincide for ASCII characters) key code of 97
    corresponding the ASCII value of @c a. And if the same key is pressed but
    with Shift being held (or Caps Lock being active), then the key could would
    be 65, i.e. ASCII value of capital @c A.

    However for the key down and up events the returned key code will instead
    be @c A independently of the state of the modifier keys i.e. it depends
    only on physical key being pressed and is not translated to its logical
    representation using the current keyboard state. Such untranslated key
    codes are defined as follows:
        - For the letters they correspond to the @e upper case value of the
        letter.
        - For the other alphanumeric keys (e.g. @c 7 or @c +), the untranslated
        key code corresponds to the character produced by the key when it is
        pressed without Shift. E.g. in standard US keyboard layout the
        untranslated key code for the key @c =/+ in the upper right corner of
        the keyboard is 61 which is the ASCII value of @c =.
        - For the rest of the keys (i.e. special non-printable keys) it is the
        same as the normal key code as no translation is used anyhow.

    Notice that the first rule applies to all Unicode letters, not just the
    usual Latin-1 ones. However for non-Latin-1 letters only GetUnicodeKey()
    can be used to retrieve the key code as GetKeyCode() just returns @c
    WXK_NONE in this case.

    To summarize: you should handle @c wxEVT_CHAR if you need the translated
    key and @c wxEVT_KEY_DOWN if you only need the value of the key itself,
    independent of the current keyboard state.

    @note Not all key down events may be generated by the user. As an example,
        @c wxEVT_KEY_DOWN with @c = key code can be generated using the
        standard US keyboard layout but not using the German one because the @c
        = key corresponds to Shift-0 key combination in this layout and the key
        code for it is @c 0, not @c =. Because of this you should avoid
        requiring your users to type key events that might be impossible to
        enter on their keyboard.


    Another difference between key and char events is that another kind of
    translation is done for the latter ones when the Control key is pressed:
    char events for ASCII letters in this case carry codes corresponding to the
    ASCII value of Ctrl-Latter, i.e. 1 for Ctrl-A, 2 for Ctrl-B and so on until
    26 for Ctrl-Z. This is convenient for terminal-like applications and can be
    completely ignored by all the other ones (if you need to handle Ctrl-A it
    is probably a better idea to use the key event rather than the char one).
    Notice that currently no translation is done for the presses of @c [, @c
    \\, @c ], @c ^ and @c _ keys which might be mapped to ASCII values from 27
    to 31.
    Since version 2.9.2, the enum values @c WXK_CONTROL_A - @c WXK_CONTROL_Z
    can be used instead of the non-descriptive constant values 1-26.

    Finally, modifier keys only generate key events but no char events at all.
    The modifiers keys are @c WXK_SHIFT, @c WXK_CONTROL, @c WXK_ALT and various
    @c WXK_WINDOWS_XXX from ::wxKeyCode enum.

    Modifier keys events are special in one additional aspect: usually the
    keyboard state associated with a key press is well defined, e.g.
    wxKeyboardState::ShiftDown() returns @c true only if the Shift key was held
    pressed when the key that generated this event itself was pressed. There is
    an ambiguity for the key press events for Shift key itself however. By
    convention, it is considered to be already pressed when it is pressed and
    already released when it is released. In other words, @c wxEVT_KEY_DOWN
    event for the Shift key itself will have @c wxMOD_SHIFT in GetModifiers()
    and ShiftDown() will return true while the @c wxEVT_KEY_UP event for Shift
    itself will not have @c wxMOD_SHIFT in its modifiers and ShiftDown() will
    return false.


    @b Tip: You may discover the key codes and modifiers generated by all the
        keys on your system interactively by running the @ref
        page_samples_keyboard wxWidgets sample and pressing some keys in it.

    @note If a key down (@c EVT_KEY_DOWN) event is caught and the event handler
          does not call @c event.Skip() then the corresponding char event
          (@c EVT_CHAR) will not happen. This is by design and enables the
          programs that handle both types of events to avoid processing the
          same key twice. As a consequence, if you do not want to suppress the
          @c wxEVT_CHAR events for the keys you handle, always call @c
          event.Skip() in your @c wxEVT_KEY_DOWN handler. Not doing may also
          prevent accelerators defined using this key from working.

    @note If a key is maintained in a pressed state, you will typically get a
          lot of (automatically generated) key down events but only one key up
          one at the end when the key is released so it is wrong to assume that
          there is one up event corresponding to each down one.

    @note For Windows programmers: The key and char events in wxWidgets are
          similar to but slightly different from Windows @c WM_KEYDOWN and
          @c WM_CHAR events. In particular, Alt-x combination will generate a
          char event in wxWidgets (unless it is used as an accelerator) and
          almost all keys, including ones without ASCII equivalents, generate
          char events too.


    @beginEventTable{wxKeyEvent}
    @event{EVT_KEY_DOWN(func)}
        Process a @c wxEVT_KEY_DOWN event (any key has been pressed). If this
        event is handled and not skipped, @c wxEVT_CHAR will not be generated
        at all for this key press (but @c wxEVT_KEY_UP will be).
    @event{EVT_KEY_UP(func)}
        Process a @c wxEVT_KEY_UP event (any key has been released).
    @event{EVT_CHAR(func)}
        Process a @c wxEVT_CHAR event.
    @event{EVT_CHAR_HOOK(func)}
        Process a @c wxEVT_CHAR_HOOK event. Unlike all the other key events,
        this event is propagated upwards the window hierarchy which allows
        intercepting it in the parent window of the focused window to which it
        is sent initially (if there is no focused window, this event is sent to
        the wxApp global object). It is also generated before any other key
        events and so gives the parent window an opportunity to modify the
        keyboard handling of its children, e.g. it is used internally by
        wxWidgets in some ports to intercept pressing Esc key in any child of a
        dialog to close the dialog itself when it's pressed. By default, if
        this event is handled, i.e. the handler doesn't call wxEvent::Skip(),
        neither @c wxEVT_KEY_DOWN nor @c wxEVT_CHAR events will be generated
        (although @c wxEVT_KEY_UP still will be), i.e. it replaces the normal
        key events. However by calling the special DoAllowNextEvent() method
        you can handle @c wxEVT_CHAR_HOOK and still allow normal events
        generation. This is something that is rarely useful but can be required
        if you need to prevent a parent @c wxEVT_CHAR_HOOK handler from running
        without suppressing the normal key events. Finally notice that this
        event is not generated when the mouse is captured as it is considered
        that the window which has the capture should receive all the keyboard
        events too without allowing its parent wxTopLevelWindow to interfere
        with their processing.
    @endEventTable

    @see wxKeyboardState

    @library{wxcore}
    @category{events}
*/
class wxKeyEvent : public wxEvent,
                   public wxKeyboardState
{
public:
    /**
        Constructor.
        Currently, the only valid event types are @c wxEVT_CHAR and @c wxEVT_CHAR_HOOK.
    */
    wxKeyEvent(wxEventType keyEventType = wxEVT_NULL);

    /**
        Returns the key code of the key that generated this event.

        ASCII symbols return normal ASCII values, while events from special
        keys such as "left cursor arrow" (@c WXK_LEFT) return values outside of
        the ASCII range. See ::wxKeyCode for a full list of the virtual key
        codes.

        Note that this method returns a meaningful value only for special
        non-alphanumeric keys or if the user entered a Latin-1 character (this
        includes ASCII and the accented letters found in Western European
        languages but not letters of other alphabets such as e.g. Cyrillic).
        Otherwise it simply method returns @c WXK_NONE and GetUnicodeKey()
        should be used to obtain the corresponding Unicode character.

        Using GetUnicodeKey() is in general the right thing to do if you are
        interested in the characters typed by the user, GetKeyCode() should be
        only used for special keys (for which GetUnicodeKey() returns @c
        WXK_NONE). To handle both kinds of keys you might write:
        @code
            void MyHandler::OnChar(wxKeyEvent& event)
            {
                wxChar uc = event.GetUnicodeKey();
                if ( uc != WXK_NONE )
                {
                    // It's a "normal" character. Notice that this includes
                    // control characters in 1..31 range, e.g. WXK_RETURN or
                    // WXK_BACK, so check for them explicitly.
                    if ( uc >= 32 )
                    {
                        wxLogMessage("You pressed '%c'", uc);
                    }
                    else
                    {
                        // It's a control character
                        ...
                    }
                }
                else // No Unicode equivalent.
                {
                    // It's a special key, deal with all the known ones:
                    switch ( GetKeyCode() )
                    {
                        case WXK_LEFT:
                        case WXK_RIGHT:
                            ... move cursor ...
                            break;

                        case WXK_F1:
                            ... give help ...
                            break;
                    }
                }
            }
        @endcode
    */
    int GetKeyCode() const;

    /**
        Returns true if the key is in the given key category.

        @param category
            A bitwise combination of named ::wxKeyCategoryFlags constants.

        @since 2.9.1
    */
    bool IsKeyInCategory(int category) const;

    //@{
    /**
        Obtains the position (in client coordinates) at which the key was pressed.

        Notice that this position is simply the current mouse pointer position
        and has no special relationship to the key event itself.
    */
    wxPoint GetPosition() const;
    void GetPosition(long* x, long* y) const;
    //@}

    /**
        Returns the raw key code for this event.

        The flags are platform-dependent and should only be used if the
        functionality provided by other wxKeyEvent methods is insufficient.

        Under MSW, the raw key code is the value of @c wParam parameter of the
        corresponding message.

        Under GTK, the raw key code is the @c keyval field of the corresponding
        GDK event.

        Under OS X, the raw key code is the @c keyCode field of the
        corresponding NSEvent.

        @note Currently the raw key codes are not supported by all ports, use
              @ifdef_ wxHAS_RAW_KEY_CODES to determine if this feature is available.
    */
    wxUint32 GetRawKeyCode() const;

    /**
        Returns the low level key flags for this event.

        The flags are platform-dependent and should only be used if the
        functionality provided by other wxKeyEvent methods is insufficient.

        Under MSW, the raw flags are just the value of @c lParam parameter of
        the corresponding message.

        Under GTK, the raw flags contain the @c hardware_keycode field of the
        corresponding GDK event.

        Under OS X, the raw flags contain the modifiers state.

        @note Currently the raw key flags are not supported by all ports, use
              @ifdef_ wxHAS_RAW_KEY_CODES to determine if this feature is available.
    */
    wxUint32 GetRawKeyFlags() const;

    /**
        Returns the Unicode character corresponding to this key event.

        If the key pressed doesn't have any character value (e.g. a cursor key)
        this method will return @c WXK_NONE. In this case you should use
        GetKeyCode() to retrieve the value of the key.

        This function is only available in Unicode build, i.e. when
        @c wxUSE_UNICODE is 1.
    */
    wxChar GetUnicodeKey() const;

    /**
        Returns the X position (in client coordinates) of the event.

        @see GetPosition()
    */
    wxCoord GetX() const;

    /**
        Returns the Y position (in client coordinates) of the event.

        @see GetPosition()
    */
    wxCoord GetY() const;

    /**
        Allow normal key events generation.

        Can be called from @c wxEVT_CHAR_HOOK handler to indicate that the
        generation of normal events should @em not be suppressed, as it happens
        by default when this event is handled.

        The intended use of this method is to allow some window object to
        prevent @c wxEVT_CHAR_HOOK handler in its parent window from running by
        defining its own handler for this event. Without calling this method,
        this would result in not generating @c wxEVT_KEY_DOWN nor @c wxEVT_CHAR
        events at all but by calling it you can ensure that these events would
        still be generated, even if @c wxEVT_CHAR_HOOK event was handled.

        @since 2.9.3
     */
    void DoAllowNextEvent();

    /**
        Returns @true if DoAllowNextEvent() had been called, @false by default.

        This method is used by wxWidgets itself to determine whether the normal
        key events should be generated after @c wxEVT_CHAR_HOOK processing.

        @since 2.9.3
     */
    bool IsNextEventAllowed() const;
};



enum
{
    wxJOYSTICK1,
    wxJOYSTICK2
};

// Which button is down?
enum
{
    wxJOY_BUTTON_ANY = -1,
    wxJOY_BUTTON1    = 1,
    wxJOY_BUTTON2    = 2,
    wxJOY_BUTTON3    = 4,
    wxJOY_BUTTON4    = 8
};


/**
    @class wxJoystickEvent

    This event class contains information about joystick events, particularly
    events received by windows.

    @beginEventTable{wxJoystickEvent}
    @event{EVT_JOY_BUTTON_DOWN(func)}
        Process a @c wxEVT_JOY_BUTTON_DOWN event.
    @event{EVT_JOY_BUTTON_UP(func)}
        Process a @c wxEVT_JOY_BUTTON_UP event.
    @event{EVT_JOY_MOVE(func)}
        Process a @c wxEVT_JOY_MOVE event.
    @event{EVT_JOY_ZMOVE(func)}
        Process a @c wxEVT_JOY_ZMOVE event.
    @event{EVT_JOYSTICK_EVENTS(func)}
        Processes all joystick events.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxJoystick
*/
class wxJoystickEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxJoystickEvent(wxEventType eventType = wxEVT_NULL, int state = 0,
                    int joystick = wxJOYSTICK1,
                    int change = 0);

    /**
        Returns @true if the event was a down event from the specified button
        (or any button).

        @param button
            Can be @c wxJOY_BUTTONn where @c n is 1, 2, 3 or 4; or @c wxJOY_BUTTON_ANY to
            indicate any button down event.
    */
    bool ButtonDown(int button = wxJOY_BUTTON_ANY) const;

    /**
        Returns @true if the specified button (or any button) was in a down state.

        @param button
            Can be @c wxJOY_BUTTONn where @c n is 1, 2, 3 or 4; or @c wxJOY_BUTTON_ANY to
            indicate any button down event.
    */
    bool ButtonIsDown(int button = wxJOY_BUTTON_ANY) const;

    /**
        Returns @true if the event was an up event from the specified button
        (or any button).

        @param button
            Can be @c wxJOY_BUTTONn where @c n is 1, 2, 3 or 4; or @c wxJOY_BUTTON_ANY to
            indicate any button down event.
    */
    bool ButtonUp(int button = wxJOY_BUTTON_ANY) const;

    /**
        Returns the identifier of the button changing state.

        This is a @c wxJOY_BUTTONn identifier, where @c n is one of 1, 2, 3, 4.
    */
    int GetButtonChange() const;

    /**
        Returns the down state of the buttons.

        This is a @c wxJOY_BUTTONn identifier, where @c n is one of 1, 2, 3, 4.
    */
    int GetButtonState() const;

    /**
        Returns the identifier of the joystick generating the event - one of
        wxJOYSTICK1 and wxJOYSTICK2.
    */
    int GetJoystick() const;

    /**
        Returns the x, y position of the joystick event.

        These coordinates are valid for all the events except wxEVT_JOY_ZMOVE.
    */
    wxPoint GetPosition() const;

    /**
        Returns the z position of the joystick event.

        This method can only be used for wxEVT_JOY_ZMOVE events.
    */
    int GetZPosition() const;

    /**
        Returns @true if this was a button up or down event
        (@e not 'is any button down?').
    */
    bool IsButton() const;

    /**
        Returns @true if this was an x, y move event.
    */
    bool IsMove() const;

    /**
        Returns @true if this was a z move event.
    */
    bool IsZMove() const;
};



/**
    @class wxScrollWinEvent

    A scroll event holds information about events sent from scrolling windows.

    Note that you can use the EVT_SCROLLWIN* macros for intercepting scroll window events
    from the receiving window.

    @beginEventTable{wxScrollWinEvent}
    @event{EVT_SCROLLWIN(func)}
        Process all scroll events.
    @event{EVT_SCROLLWIN_TOP(func)}
        Process @c wxEVT_SCROLLWIN_TOP scroll-to-top events.
    @event{EVT_SCROLLWIN_BOTTOM(func)}
        Process @c wxEVT_SCROLLWIN_BOTTOM scroll-to-bottom events.
    @event{EVT_SCROLLWIN_LINEUP(func)}
        Process @c wxEVT_SCROLLWIN_LINEUP line up events.
    @event{EVT_SCROLLWIN_LINEDOWN(func)}
        Process @c wxEVT_SCROLLWIN_LINEDOWN line down events.
    @event{EVT_SCROLLWIN_PAGEUP(func)}
        Process @c wxEVT_SCROLLWIN_PAGEUP page up events.
    @event{EVT_SCROLLWIN_PAGEDOWN(func)}
        Process @c wxEVT_SCROLLWIN_PAGEDOWN page down events.
    @event{EVT_SCROLLWIN_THUMBTRACK(func)}
        Process @c wxEVT_SCROLLWIN_THUMBTRACK thumbtrack events
        (frequent events sent as the user drags the thumbtrack).
    @event{EVT_SCROLLWIN_THUMBRELEASE(func)}
        Process @c wxEVT_SCROLLWIN_THUMBRELEASE thumb release events.
    @endEventTable


    @library{wxcore}
    @category{events}

    @see wxScrollEvent, @ref overview_events
*/
class wxScrollWinEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxScrollWinEvent(wxEventType commandType = wxEVT_NULL, int pos = 0,
                     int orientation = 0);

    /**
        Returns wxHORIZONTAL or wxVERTICAL, depending on the orientation of the
        scrollbar.

        @todo wxHORIZONTAL and wxVERTICAL should go in their own enum
    */
    int GetOrientation() const;

    /**
        Returns the position of the scrollbar for the thumb track and release events.

        Note that this field can't be used for the other events, you need to query
        the window itself for the current position in that case.
    */
    int GetPosition() const;

    void SetOrientation(int orient);
    void SetPosition(int pos);    
};



/**
    @class wxSysColourChangedEvent

    This class is used for system colour change events, which are generated
    when the user changes the colour settings using the control panel.
    This is only appropriate under Windows.

    @remarks
        The default event handler for this event propagates the event to child windows,
        since Windows only sends the events to top-level windows.
        If intercepting this event for a top-level window, remember to call the base
        class handler, or to pass the event on to the window's children explicitly.

    @beginEventTable{wxSysColourChangedEvent}
    @event{EVT_SYS_COLOUR_CHANGED(func)}
        Process a @c wxEVT_SYS_COLOUR_CHANGED event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxSysColourChangedEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxSysColourChangedEvent();
};



/**
    @class wxWindowCreateEvent

    This event is sent just after the actual window associated with a wxWindow
    object has been created.

    Since it is derived from wxCommandEvent, the event propagates up
    the window hierarchy.

    @beginEventTable{wxWindowCreateEvent}
    @event{EVT_WINDOW_CREATE(func)}
        Process a @c wxEVT_CREATE event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events, wxWindowDestroyEvent
*/
class wxWindowCreateEvent : public wxCommandEvent
{
public:
    /**
        Constructor.
    */
    wxWindowCreateEvent(wxWindow* win = NULL);

    /// Return the window being created.
    wxWindow *GetWindow() const;
};



/**
    @class wxPaintEvent

    A paint event is sent when a window's contents needs to be repainted.

    The handler of this event must create a wxPaintDC object and use it for
    painting the window contents. For example:
    @code
    void MyWindow::OnPaint(wxPaintEvent& event)
    {
        wxPaintDC dc(this);

        DrawMyDocument(dc);
    }
    @endcode

    Notice that you must @e not create other kinds of wxDC (e.g. wxClientDC or
    wxWindowDC) in EVT_PAINT handlers and also don't create wxPaintDC outside
    of this event handlers.


    You can optimize painting by retrieving the rectangles that have been damaged
    and only repainting these. The rectangles are in terms of the client area,
    and are unscrolled, so you will need to do some calculations using the current
    view position to obtain logical, scrolled units.
    Here is an example of using the wxRegionIterator class:
    @code
    // Called when window needs to be repainted.
    void MyWindow::OnPaint(wxPaintEvent& event)
    {
        wxPaintDC dc(this);

        // Find Out where the window is scrolled to
        int vbX,vbY;                     // Top left corner of client
        GetViewStart(&vbX,&vbY);

        int vX,vY,vW,vH;                 // Dimensions of client area in pixels
        wxRegionIterator upd(GetUpdateRegion()); // get the update rect list

        while (upd)
        {
            vX = upd.GetX();
            vY = upd.GetY();
            vW = upd.GetW();
            vH = upd.GetH();

            // Alternatively we can do this:
            // wxRect rect(upd.GetRect());

            // Repaint this rectangle
            ...some code...

            upd ++ ;
        }
    }
    @endcode

    @remarks
    Please notice that in general it is impossible to change the drawing of a
    standard control (such as wxButton) and so you shouldn't attempt to handle
    paint events for them as even if it might work on some platforms, this is
    inherently not portable and won't work everywhere.


    @beginEventTable{wxPaintEvent}
    @event{EVT_PAINT(func)}
        Process a @c wxEVT_PAINT event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxPaintEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxPaintEvent(int id = 0);
};



/**
    @class wxMaximizeEvent

    An event being sent when a top level window is maximized. Notice that it is
    not sent when the window is restored to its original size after it had been
    maximized, only a normal wxSizeEvent is generated in this case.

    Currently this event is only generated in wxMSW, wxGTK, wxOSX/Cocoa and wxOS2
    ports so portable programs should only rely on receiving @c wxEVT_SIZE and
    not necessarily this event when the window is maximized.

    @beginEventTable{wxMaximizeEvent}
    @event{EVT_MAXIMIZE(func)}
        Process a @c wxEVT_MAXIMIZE event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events, wxTopLevelWindow::Maximize,
         wxTopLevelWindow::IsMaximized
*/
class wxMaximizeEvent : public wxEvent
{
public:
    /**
        Constructor. Only used by wxWidgets internally.
    */
    wxMaximizeEvent(int id = 0);
};

/**
    The possibles modes to pass to wxUpdateUIEvent::SetMode().
*/
enum wxUpdateUIMode
{
        /** Send UI update events to all windows. */
    wxUPDATE_UI_PROCESS_ALL,

        /** Send UI update events to windows that have
            the wxWS_EX_PROCESS_UI_UPDATES flag specified. */
    wxUPDATE_UI_PROCESS_SPECIFIED
};


/**
    @class wxUpdateUIEvent

    This class is used for pseudo-events which are called by wxWidgets
    to give an application the chance to update various user interface elements.

    Without update UI events, an application has to work hard to check/uncheck,
    enable/disable, show/hide, and set the text for elements such as menu items
    and toolbar buttons. The code for doing this has to be mixed up with the code
    that is invoked when an action is invoked for a menu item or button.

    With update UI events, you define an event handler to look at the state of the
    application and change UI elements accordingly. wxWidgets will call your member
    functions in idle time, so you don't have to worry where to call this code.

    In addition to being a clearer and more declarative method, it also means you don't
    have to worry whether you're updating a toolbar or menubar identifier. The same
    handler can update a menu item and toolbar button, if the identifier is the same.
    Instead of directly manipulating the menu or button, you call functions in the event
    object, such as wxUpdateUIEvent::Check. wxWidgets will determine whether such a
    call has been made, and which UI element to update.

    These events will work for popup menus as well as menubars. Just before a menu is
    popped up, wxMenu::UpdateUI is called to process any UI events for the window that
    owns the menu.

    If you find that the overhead of UI update processing is affecting your application,
    you can do one or both of the following:
    @li Call wxUpdateUIEvent::SetMode with a value of wxUPDATE_UI_PROCESS_SPECIFIED,
        and set the extra style wxWS_EX_PROCESS_UI_UPDATES for every window that should
        receive update events. No other windows will receive update events.
    @li Call wxUpdateUIEvent::SetUpdateInterval with a millisecond value to set the delay
        between updates. You may need to call wxWindow::UpdateWindowUI at critical points,
        for example when a dialog is about to be shown, in case the user sees a slight
        delay before windows are updated.

    Note that although events are sent in idle time, defining a wxIdleEvent handler
    for a window does not affect this because the events are sent from wxWindow::OnInternalIdle
    which is always called in idle time.

    wxWidgets tries to optimize update events on some platforms.
    On Windows and GTK+, events for menubar items are only sent when the menu is about
    to be shown, and not in idle time.


    @beginEventTable{wxUpdateUIEvent}
    @event{EVT_UPDATE_UI(id, func)}
        Process a @c wxEVT_UPDATE_UI event for the command with the given id.
    @event{EVT_UPDATE_UI_RANGE(id1, id2, func)}
        Process a @c wxEVT_UPDATE_UI event for any command with id included in the given range.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxUpdateUIEvent : public wxCommandEvent
{
public:
    /**
        Constructor.
    */
    wxUpdateUIEvent(wxWindowID commandId = 0);

    /**
        Returns @true if it is appropriate to update (send UI update events to)
        this window.

        This function looks at the mode used (see wxUpdateUIEvent::SetMode),
        the wxWS_EX_PROCESS_UI_UPDATES flag in @a window, the time update events
        were last sent in idle time, and the update interval, to determine whether
        events should be sent to this window now. By default this will always
        return @true because the update mode is initially wxUPDATE_UI_PROCESS_ALL
        and the interval is set to 0; so update events will be sent as often as
        possible. You can reduce the frequency that events are sent by changing the
        mode and/or setting an update interval.

        @see ResetUpdateTime(), SetUpdateInterval(), SetMode()
    */
    static bool CanUpdate(wxWindow* window);

    /**
        Check or uncheck the UI element.
    */
    void Check(bool check);

    /**
        Enable or disable the UI element.
    */
    void Enable(bool enable);

    /**
        Returns @true if the UI element should be checked.
    */
    bool GetChecked() const;

    /**
        Returns @true if the UI element should be enabled.
    */
    bool GetEnabled() const;

    /**
        Static function returning a value specifying how wxWidgets will send update
        events: to all windows, or only to those which specify that they will process
        the events.

        @see SetMode()
    */
    static wxUpdateUIMode GetMode();

    /**
        Returns @true if the application has called Check().
        For wxWidgets internal use only.
    */
    bool GetSetChecked() const;

    /**
        Returns @true if the application has called Enable().
        For wxWidgets internal use only.
    */
    bool GetSetEnabled() const;

    /**
        Returns @true if the application has called Show().
        For wxWidgets internal use only.
    */
    bool GetSetShown() const;

    /**
        Returns @true if the application has called SetText().
        For wxWidgets internal use only.
    */
    bool GetSetText() const;

    /**
        Returns @true if the UI element should be shown.
    */
    bool GetShown() const;

    /**
        Returns the text that should be set for the UI element.
    */
    wxString GetText() const;

    /**
        Returns the current interval between updates in milliseconds.
        The value -1 disables updates, 0 updates as frequently as possible.

        @see SetUpdateInterval().
    */
    static long GetUpdateInterval();

    /**
        Used internally to reset the last-updated time to the current time.

        It is assumed that update events are normally sent in idle time, so this
        is called at the end of idle processing.

        @see CanUpdate(), SetUpdateInterval(), SetMode()
    */
    static void ResetUpdateTime();

    /**
        Specify how wxWidgets will send update events: to all windows, or only to
        those which specify that they will process the events.

        @param mode
            this parameter may be one of the ::wxUpdateUIMode enumeration values.
            The default mode is wxUPDATE_UI_PROCESS_ALL.
    */
    static void SetMode(wxUpdateUIMode mode);

    /**
        Sets the text for this UI element.
    */
    void SetText(const wxString& text);

    /**
        Sets the interval between updates in milliseconds.

        Set to -1 to disable updates, or to 0 to update as frequently as possible.
        The default is 0.

        Use this to reduce the overhead of UI update events if your application
        has a lot of windows. If you set the value to -1 or greater than 0,
        you may also need to call wxWindow::UpdateWindowUI at appropriate points
        in your application, such as when a dialog is about to be shown.
    */
    static void SetUpdateInterval(long updateInterval);

    /**
        Show or hide the UI element.
    */
    void Show(bool show);
};



/**
    @class wxClipboardTextEvent

    This class represents the events generated by a control (typically a
    wxTextCtrl but other windows can generate these events as well) when its
    content gets copied or cut to, or pasted from the clipboard.

    There are three types of corresponding events @c wxEVT_COMMAND_TEXT_COPY,
    @c wxEVT_COMMAND_TEXT_CUT and @c wxEVT_COMMAND_TEXT_PASTE.

    If any of these events is processed (without being skipped) by an event
    handler, the corresponding operation doesn't take place which allows to
    prevent the text from being copied from or pasted to a control. It is also
    possible to examine the clipboard contents in the PASTE event handler and
    transform it in some way before inserting in a control -- for example,
    changing its case or removing invalid characters.

    Finally notice that a CUT event is always preceded by the COPY event which
    makes it possible to only process the latter if it doesn't matter if the
    text was copied or cut.

    @note
    These events are currently only generated by wxTextCtrl in wxGTK and wxOSX
    but are also generated by wxComboBox without wxCB_READONLY style in wxMSW.

    @beginEventTable{wxClipboardTextEvent}
    @event{EVT_TEXT_COPY(id, func)}
           Some or all of the controls content was copied to the clipboard.
    @event{EVT_TEXT_CUT(id, func)}
           Some or all of the controls content was cut (i.e. copied and
           deleted).
    @event{EVT_TEXT_PASTE(id, func)}
           Clipboard content was pasted into the control.
    @endEventTable


    @library{wxcore}
    @category{events}

    @see wxClipboard
*/
class wxClipboardTextEvent : public wxCommandEvent
{
public:
    /**
        Constructor.
    */
    wxClipboardTextEvent(wxEventType commandType = wxEVT_NULL, int id = 0);
};

/**
    Possible axis values for mouse wheel scroll events.

    @since 2.9.4
 */
enum wxMouseWheelAxis
{
    wxMOUSE_WHEEL_VERTICAL,     ///< Vertical scroll event.
    wxMOUSE_WHEEL_HORIZONTAL    ///< Horizontal scroll event.
};


/**
    @class wxMouseEvent

    This event class contains information about the events generated by the mouse:
    they include mouse buttons press and release events and mouse move events.

    All mouse events involving the buttons use @c wxMOUSE_BTN_LEFT for the
    left mouse button, @c wxMOUSE_BTN_MIDDLE for the middle one and
    @c wxMOUSE_BTN_RIGHT for the right one. And if the system supports more
    buttons, the @c wxMOUSE_BTN_AUX1 and @c wxMOUSE_BTN_AUX2 events
    can also be generated. Note that not all mice have even a middle button so a
    portable application should avoid relying on the events from it (but the right
    button click can be emulated using the left mouse button with the control key
    under Mac platforms with a single button mouse).

    For the @c wxEVT_ENTER_WINDOW and @c wxEVT_LEAVE_WINDOW events
    purposes, the mouse is considered to be inside the window if it is in the
    window client area and not inside one of its children. In other words, the
    parent window receives @c wxEVT_LEAVE_WINDOW event not only when the
    mouse leaves the window entirely but also when it enters one of its children.

    The position associated with a mouse event is expressed in the window
    coordinates of the window which generated the event, you can use
    wxWindow::ClientToScreen() to convert it to screen coordinates and possibly
    call wxWindow::ScreenToClient() next to convert it to window coordinates of
    another window.

    @note Note that under Windows CE mouse enter and leave events are not natively
          supported by the system but are generated by wxWidgets itself. This has several
          drawbacks: the LEAVE_WINDOW event might be received some time after the mouse
          left the window and the state variables for it may have changed during this time.

    @note Note the difference between methods like wxMouseEvent::LeftDown and
          the inherited wxMouseState::LeftIsDown: the former returns @true when
          the event corresponds to the left mouse button click while the latter
          returns @true if the left mouse button is currently being pressed.
          For example, when the user is dragging the mouse you can use
          wxMouseEvent::LeftIsDown to test whether the left mouse button is
          (still) depressed. Also, by convention, if wxMouseEvent::LeftDown
          returns @true, wxMouseEvent::LeftIsDown will also return @true in
          wxWidgets whatever the underlying GUI behaviour is (which is
          platform-dependent). The same applies, of course, to other mouse
          buttons as well.


    @beginEventTable{wxMouseEvent}
    @event{EVT_LEFT_DOWN(func)}
        Process a @c wxEVT_LEFT_DOWN event. The handler of this event should normally
        call event.Skip() to allow the default processing to take place as otherwise
        the window under mouse wouldn't get the focus.
    @event{EVT_LEFT_UP(func)}
        Process a @c wxEVT_LEFT_UP event.
    @event{EVT_LEFT_DCLICK(func)}
        Process a @c wxEVT_LEFT_DCLICK event.
    @event{EVT_MIDDLE_DOWN(func)}
        Process a @c wxEVT_MIDDLE_DOWN event.
    @event{EVT_MIDDLE_UP(func)}
        Process a @c wxEVT_MIDDLE_UP event.
    @event{EVT_MIDDLE_DCLICK(func)}
        Process a @c wxEVT_MIDDLE_DCLICK event.
    @event{EVT_RIGHT_DOWN(func)}
        Process a @c wxEVT_RIGHT_DOWN event.
    @event{EVT_RIGHT_UP(func)}
        Process a @c wxEVT_RIGHT_UP event.
    @event{EVT_RIGHT_DCLICK(func)}
        Process a @c wxEVT_RIGHT_DCLICK event.
    @event{EVT_MOUSE_AUX1_DOWN(func)}
        Process a @c wxEVT_AUX1_DOWN event.
    @event{EVT_MOUSE_AUX1_UP(func)}
        Process a @c wxEVT_AUX1_UP event.
    @event{EVT_MOUSE_AUX1_DCLICK(func)}
        Process a @c wxEVT_AUX1_DCLICK event.
    @event{EVT_MOUSE_AUX2_DOWN(func)}
        Process a @c wxEVT_AUX2_DOWN event.
    @event{EVT_MOUSE_AUX2_UP(func)}
        Process a @c wxEVT_AUX2_UP event.
    @event{EVT_MOUSE_AUX2_DCLICK(func)}
        Process a @c wxEVT_AUX2_DCLICK event.
    @event{EVT_MOTION(func)}
        Process a @c wxEVT_MOTION event.
    @event{EVT_ENTER_WINDOW(func)}
        Process a @c wxEVT_ENTER_WINDOW event.
    @event{EVT_LEAVE_WINDOW(func)}
        Process a @c wxEVT_LEAVE_WINDOW event.
    @event{EVT_MOUSEWHEEL(func)}
        Process a @c wxEVT_MOUSEWHEEL event.
    @event{EVT_MOUSE_EVENTS(func)}
        Process all mouse events.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxKeyEvent
*/
class wxMouseEvent : public wxEvent,
                     public wxMouseState
{
public:
    /**
        Constructor. Valid event types are:

         @li @c wxEVT_ENTER_WINDOW
         @li @c wxEVT_LEAVE_WINDOW
         @li @c wxEVT_LEFT_DOWN
         @li @c wxEVT_LEFT_UP
         @li @c wxEVT_LEFT_DCLICK
         @li @c wxEVT_MIDDLE_DOWN
         @li @c wxEVT_MIDDLE_UP
         @li @c wxEVT_MIDDLE_DCLICK
         @li @c wxEVT_RIGHT_DOWN
         @li @c wxEVT_RIGHT_UP
         @li @c wxEVT_RIGHT_DCLICK
         @li @c wxEVT_AUX1_DOWN
         @li @c wxEVT_AUX1_UP
         @li @c wxEVT_AUX1_DCLICK
         @li @c wxEVT_AUX2_DOWN
         @li @c wxEVT_AUX2_UP
         @li @c wxEVT_AUX2_DCLICK
         @li @c wxEVT_MOTION
         @li @c wxEVT_MOUSEWHEEL
    */
    wxMouseEvent(wxEventType mouseEventType = wxEVT_NULL);

    /**
        Returns @true if the event was a first extra button double click.
    */
    bool Aux1DClick() const;

    /**
        Returns @true if the first extra button mouse button changed to down.
    */
    bool Aux1Down() const;

    /**
        Returns @true if the first extra button mouse button changed to up.
    */
    bool Aux1Up() const;

    /**
        Returns @true if the event was a second extra button double click.
    */
    bool Aux2DClick() const;

    /**
        Returns @true if the second extra button mouse button changed to down.
    */
    bool Aux2Down() const;

    /**
        Returns @true if the second extra button mouse button changed to up.
    */
    bool Aux2Up() const;

    /**
        Returns @true if the event was generated by the specified button.

        @see wxMouseState::ButtoinIsDown()
    */
    bool Button(wxMouseButton but) const;

    /**
        If the argument is omitted, this returns @true if the event was a mouse
        double click event. Otherwise the argument specifies which double click event
        was generated (see Button() for the possible values).
    */
    bool ButtonDClick(wxMouseButton but = wxMOUSE_BTN_ANY) const;

    /**
        If the argument is omitted, this returns @true if the event was a mouse
        button down event. Otherwise the argument specifies which button-down event
        was generated (see Button() for the possible values).
    */
    bool ButtonDown(wxMouseButton but = wxMOUSE_BTN_ANY) const;

    /**
        If the argument is omitted, this returns @true if the event was a mouse
        button up event. Otherwise the argument specifies which button-up event
        was generated (see Button() for the possible values).
    */
    bool ButtonUp(wxMouseButton but = wxMOUSE_BTN_ANY) const;

    /**
        Returns @true if this was a dragging event (motion while a button is depressed).

        @see Moving()
    */
    bool Dragging() const;

    /**
        Returns @true if the mouse was entering the window.

        @see Leaving()
    */
    bool Entering() const;

    /**
        Returns the mouse button which generated this event or @c wxMOUSE_BTN_NONE
        if no button is involved (for mouse move, enter or leave event, for example).
        Otherwise @c wxMOUSE_BTN_LEFT is returned for the left button down, up and
        double click events, @c wxMOUSE_BTN_MIDDLE and @c wxMOUSE_BTN_RIGHT
        for the same events for the middle and the right buttons respectively.
    */
    int GetButton() const;

    /**
        Returns the number of mouse clicks for this event: 1 for a simple click, 2
        for a double-click, 3 for a triple-click and so on.

        Currently this function is implemented only in wxMac and returns -1 for the
        other platforms (you can still distinguish simple clicks from double-clicks as
        they generate different kinds of events however).

        @since 2.9.0
    */
    int GetClickCount() const;

    /**
        Returns the configured number of lines (or whatever) to be scrolled per
        wheel action. Defaults to three.
    */
    int GetLinesPerAction() const;

    /**
        Returns the logical mouse position in pixels (i.e. translated according to the
        translation set for the DC, which usually indicates that the window has been
        scrolled).
    */
    wxPoint GetLogicalPosition(const wxDC& dc) const;

    /**
        Get wheel delta, normally 120.

        This is the threshold for action to be taken, and one such action
        (for example, scrolling one increment) should occur for each delta.
    */
    int GetWheelDelta() const;

    /**
        Get wheel rotation, positive or negative indicates direction of rotation.

        Current devices all send an event when rotation is at least +/-WheelDelta, but
        finer resolution devices can be created in the future.

        Because of this you shouldn't assume that one event is equal to 1 line, but you
        should be able to either do partial line scrolling or wait until several
        events accumulate before scrolling.
    */
    int GetWheelRotation() const;

    /**
        Gets the axis the wheel operation concerns.

        Usually the mouse wheel is used to scroll vertically so @c
        wxMOUSE_WHEEL_VERTICAL is returned but some mice (and most trackpads)
        also allow to use the wheel to scroll horizontally in which case
        @c wxMOUSE_WHEEL_HORIZONTAL is returned.

        Notice that before wxWidgets 2.9.4 this method returned @c int.
    */
    wxMouseWheelAxis GetWheelAxis() const;

    /**
        Returns @true if the event was a mouse button event (not necessarily a button
        down event - that may be tested using ButtonDown()).
    */
    bool IsButton() const;

    /**
        Returns @true if the system has been setup to do page scrolling with
        the mouse wheel instead of line scrolling.
    */
    bool IsPageScroll() const;

    /**
        Returns @true if the mouse was leaving the window.

        @see Entering().
    */
    bool Leaving() const;

    /**
        Returns @true if the event was a left double click.
    */
    bool LeftDClick() const;

    /**
        Returns @true if the left mouse button changed to down.
    */
    bool LeftDown() const;

    /**
        Returns @true if the left mouse button changed to up.
    */
    bool LeftUp() const;

    /**
        Returns @true if the Meta key was down at the time of the event.
    */
    bool MetaDown() const;

    /**
        Returns @true if the event was a middle double click.
    */
    bool MiddleDClick() const;

    /**
        Returns @true if the middle mouse button changed to down.
    */
    bool MiddleDown() const;

    /**
        Returns @true if the middle mouse button changed to up.
    */
    bool MiddleUp() const;

    /**
        Returns @true if this was a motion event and no mouse buttons were pressed.
        If any mouse button is held pressed, then this method returns @false and
        Dragging() returns @true.
    */
    bool Moving() const;

    /**
        Returns @true if the event was a right double click.
    */
    bool RightDClick() const;

    /**
        Returns @true if the right mouse button changed to down.
    */
    bool RightDown() const;

    /**
        Returns @true if the right mouse button changed to up.
    */
    bool RightUp() const;
};



/**
    @class wxDropFilesEvent

    This class is used for drop files events, that is, when files have been dropped
    onto the window. This functionality is currently only available under Windows.

    The window must have previously been enabled for dropping by calling
    wxWindow::DragAcceptFiles().

    Important note: this is a separate implementation to the more general drag and drop
    implementation documented in the @ref overview_dnd. It uses the older, Windows
    message-based approach of dropping files.

    @beginEventTable{wxDropFilesEvent}
    @event{EVT_DROP_FILES(func)}
        Process a @c wxEVT_DROP_FILES event.
    @endEventTable

    @onlyfor{wxmsw}

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxDropFilesEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxDropFilesEvent(wxEventType id = 0, int noFiles = 0,
                     wxString* files = NULL);

    /**
        Returns an array of filenames.
    */
    wxString* GetFiles() const;

    /**
        Returns the number of files dropped.
    */
    int GetNumberOfFiles() const;

    /**
        Returns the position at which the files were dropped.
        Returns an array of filenames.
    */
    wxPoint GetPosition() const;
};



/**
    @class wxCommandEvent

    This event class contains information about command events, which originate
    from a variety of simple controls.

    Note that wxCommandEvents and wxCommandEvent-derived event classes by default
    and unlike other wxEvent-derived classes propagate upward from the source
    window (the window which emits the event) up to the first parent which processes
    the event. Be sure to read @ref overview_events_propagation.

    More complex controls, such as wxTreeCtrl, have separate command event classes.

    @beginEventTable{wxCommandEvent}
    @event{EVT_COMMAND(id, event, func)}
        Process a command, supplying the window identifier, command event identifier,
        and member function.
    @event{EVT_COMMAND_RANGE(id1, id2, event, func)}
        Process a command for a range of window identifiers, supplying the minimum and
        maximum window identifiers, command event identifier, and member function.
    @event{EVT_BUTTON(id, func)}
        Process a @c wxEVT_COMMAND_BUTTON_CLICKED command, which is generated by a wxButton control.
    @event{EVT_CHECKBOX(id, func)}
        Process a @c wxEVT_COMMAND_CHECKBOX_CLICKED command, which is generated by a wxCheckBox control.
    @event{EVT_CHOICE(id, func)}
        Process a @c wxEVT_COMMAND_CHOICE_SELECTED command, which is generated by a wxChoice control.
    @event{EVT_COMBOBOX(id, func)}
        Process a @c wxEVT_COMMAND_COMBOBOX_SELECTED command, which is generated by a wxComboBox control.
    @event{EVT_LISTBOX(id, func)}
        Process a @c wxEVT_COMMAND_LISTBOX_SELECTED command, which is generated by a wxListBox control.
    @event{EVT_LISTBOX_DCLICK(id, func)}
        Process a @c wxEVT_COMMAND_LISTBOX_DOUBLECLICKED command, which is generated by a wxListBox control.
    @event{EVT_CHECKLISTBOX(id, func)}
        Process a @c wxEVT_COMMAND_CHECKLISTBOX_TOGGLED command, which is generated by a wxCheckListBox control.
    @event{EVT_MENU(id, func)}
        Process a @c wxEVT_COMMAND_MENU_SELECTED command, which is generated by a menu item.
    @event{EVT_MENU_RANGE(id1, id2, func)}
        Process a @c wxEVT_COMMAND_MENU_RANGE command, which is generated by a range of menu items.
    @event{EVT_CONTEXT_MENU(func)}
        Process the event generated when the user has requested a popup menu to appear by
        pressing a special keyboard key (under Windows) or by right clicking the mouse.
    @event{EVT_RADIOBOX(id, func)}
        Process a @c wxEVT_COMMAND_RADIOBOX_SELECTED command, which is generated by a wxRadioBox control.
    @event{EVT_RADIOBUTTON(id, func)}
        Process a @c wxEVT_COMMAND_RADIOBUTTON_SELECTED command, which is generated by a wxRadioButton control.
    @event{EVT_SCROLLBAR(id, func)}
        Process a @c wxEVT_COMMAND_SCROLLBAR_UPDATED command, which is generated by a wxScrollBar
        control. This is provided for compatibility only; more specific scrollbar event macros
        should be used instead (see wxScrollEvent).
    @event{EVT_SLIDER(id, func)}
        Process a @c wxEVT_COMMAND_SLIDER_UPDATED command, which is generated by a wxSlider control.
    @event{EVT_TEXT(id, func)}
        Process a @c wxEVT_COMMAND_TEXT_UPDATED command, which is generated by a wxTextCtrl control.
    @event{EVT_TEXT_ENTER(id, func)}
        Process a @c wxEVT_COMMAND_TEXT_ENTER command, which is generated by a wxTextCtrl control.
        Note that you must use wxTE_PROCESS_ENTER flag when creating the control if you want it
        to generate such events.
    @event{EVT_TEXT_MAXLEN(id, func)}
        Process a @c wxEVT_COMMAND_TEXT_MAXLEN command, which is generated by a wxTextCtrl control
        when the user tries to enter more characters into it than the limit previously set
        with SetMaxLength().
    @event{EVT_TOGGLEBUTTON(id, func)}
        Process a @c wxEVT_COMMAND_TOGGLEBUTTON_CLICKED event.
    @event{EVT_TOOL(id, func)}
        Process a @c wxEVT_COMMAND_TOOL_CLICKED event (a synonym for @c wxEVT_COMMAND_MENU_SELECTED).
        Pass the id of the tool.
    @event{EVT_TOOL_RANGE(id1, id2, func)}
        Process a @c wxEVT_COMMAND_TOOL_CLICKED event for a range of identifiers. Pass the ids of the tools.
    @event{EVT_TOOL_RCLICKED(id, func)}
        Process a @c wxEVT_COMMAND_TOOL_RCLICKED event. Pass the id of the tool.  (Not available on wxOSX.)
    @event{EVT_TOOL_RCLICKED_RANGE(id1, id2, func)}
        Process a @c wxEVT_COMMAND_TOOL_RCLICKED event for a range of ids. Pass the ids of the tools.  (Not available on wxOSX.)
    @event{EVT_TOOL_ENTER(id, func)}
        Process a @c wxEVT_COMMAND_TOOL_ENTER event. Pass the id of the toolbar itself.
        The value of wxCommandEvent::GetSelection() is the tool id, or -1 if the mouse cursor
        has moved off a tool.  (Not available on wxOSX.)
    @event{EVT_COMMAND_LEFT_CLICK(id, func)}
        Process a @c wxEVT_COMMAND_LEFT_CLICK command, which is generated by a control (wxMSW only).
    @event{EVT_COMMAND_LEFT_DCLICK(id, func)}
        Process a @c wxEVT_COMMAND_LEFT_DCLICK command, which is generated by a control (wxMSW only).
    @event{EVT_COMMAND_RIGHT_CLICK(id, func)}
        Process a @c wxEVT_COMMAND_RIGHT_CLICK command, which is generated by a control (wxMSW only).
    @event{EVT_COMMAND_SET_FOCUS(id, func)}
        Process a @c wxEVT_COMMAND_SET_FOCUS command, which is generated by a control (wxMSW only).
    @event{EVT_COMMAND_KILL_FOCUS(id, func)}
        Process a @c wxEVT_COMMAND_KILL_FOCUS command, which is generated by a control (wxMSW only).
    @event{EVT_COMMAND_ENTER(id, func)}
        Process a @c wxEVT_COMMAND_ENTER command, which is generated by a control.
    @endEventTable

    @library{wxcore}
    @category{events}
*/
class wxCommandEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxCommandEvent(wxEventType commandEventType = wxEVT_NULL, int id = 0);

    /**
        Returns client data pointer for a listbox or choice selection event
        (not valid for a deselection).
    */
    void* GetClientData() const;

    /**
        Returns client object pointer for a listbox or choice selection event
        (not valid for a deselection).
    */
    wxClientData* GetClientObject() const;

    /**
        Returns extra information dependent on the event objects type.

        If the event comes from a listbox selection, it is a boolean
        determining whether the event was a selection (@true) or a
        deselection (@false). A listbox deselection only occurs for
        multiple-selection boxes, and in this case the index and string values
        are indeterminate and the listbox must be examined by the application.
    */
    long GetExtraLong() const;

    /**
        Returns the integer identifier corresponding to a listbox, choice or
        radiobox selection (only if the event was a selection, not a deselection),
        or a boolean value representing the value of a checkbox.

        For a menu item, this method returns -1 if the item is not checkable or
        a boolean value (true or false) for checkable items indicating the new
        state of the item.
    */
    int GetInt() const;

    /**
        Returns item index for a listbox or choice selection event (not valid for
        a deselection).
    */
    int GetSelection() const;

    /**
        Returns item string for a listbox or choice selection event. If one
        or several items have been deselected, returns the index of the first
        deselected item. If some items have been selected and others deselected
        at the same time, it will return the index of the first selected item.
    */
    wxString GetString() const;

    /**
        This method can be used with checkbox and menu events: for the checkboxes, the
        method returns @true for a selection event and @false for a deselection one.
        For the menu events, this method indicates if the menu item just has become
        checked or unchecked (and thus only makes sense for checkable menu items).

        Notice that this method cannot be used with wxCheckListBox currently.
    */
    bool IsChecked() const;

    /**
        For a listbox or similar event, returns @true if it is a selection, @false
        if it is a deselection. If some items have been selected and others deselected
        at the same time, it will return @true.
    */
    bool IsSelection() const;

    /**
        Sets the client data for this event.
    */
    void SetClientData(void* clientData);

    /**
        Sets the client object for this event. The client object is not owned by the
        event object and the event object will not delete the client object in its destructor.

        The client object must be owned and deleted by another object (e.g. a control)
        that has longer life time than the event object.
    */
    void SetClientObject(wxClientData* clientObject);

    /**
        Sets the @b m_extraLong member.
    */
    void SetExtraLong(long extraLong);

    /**
        Sets the @b m_commandInt member.
    */
    void SetInt(int intCommand);

    /**
        Sets the @b m_commandString member.
    */
    void SetString(const wxString& string);
};



/**
    @class wxActivateEvent

    An activate event is sent when a window or application is being activated
    or deactivated.

    @beginEventTable{wxActivateEvent}
    @event{EVT_ACTIVATE(func)}
        Process a @c wxEVT_ACTIVATE event.
    @event{EVT_ACTIVATE_APP(func)}
        Process a @c wxEVT_ACTIVATE_APP event.
        This event is received by the wxApp-derived instance only.
    @event{EVT_HIBERNATE(func)}
        Process a hibernate event, supplying the member function. This event applies
        to wxApp only, and only on Windows SmartPhone and PocketPC.
        It is generated when the system is low on memory; the application should free
        up as much memory as possible, and restore full working state when it receives
        a @c wxEVT_ACTIVATE or @c wxEVT_ACTIVATE_APP event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events, wxApp::IsActive
*/
class wxActivateEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxActivateEvent(wxEventType eventType = wxEVT_NULL, bool active = true,
                    int id = 0);

    /**
        Returns @true if the application or window is being activated, @false otherwise.
    */
    bool GetActive() const;
};



/**
    @class wxContextMenuEvent

    This class is used for context menu events, sent to give
    the application a chance to show a context (popup) menu for a wxWindow.

    Note that if wxContextMenuEvent::GetPosition returns wxDefaultPosition, this
    means that the event originated from a keyboard context button event, and you
    should compute a suitable position yourself, for example by calling wxGetMousePosition().

    Notice that the exact sequence of mouse events is different across the
    platforms. For example, under MSW the context menu event is generated after
    @c EVT_RIGHT_UP event and only if it was not handled but under GTK the
    context menu event is generated after @c EVT_RIGHT_DOWN event. This is
    correct in the sense that it ensures that the context menu is shown
    according to the current platform UI conventions and also means that you
    must not handle (or call wxEvent::Skip() in your handler if you do have
    one) neither right mouse down nor right mouse up event if you plan on
    handling @c EVT_CONTEXT_MENU event.

    @beginEventTable{wxContextMenuEvent}
    @event{EVT_CONTEXT_MENU(func)}
        A right click (or other context menu command depending on platform) has been detected.
    @endEventTable


    @library{wxcore}
    @category{events}

    @see wxCommandEvent, @ref overview_events
*/
class wxContextMenuEvent : public wxCommandEvent
{
public:
    /**
        Constructor.
    */
    wxContextMenuEvent(wxEventType type = wxEVT_NULL, int id = 0,
                       const wxPoint& pos = wxDefaultPosition);

    /**
        Returns the position in screen coordinates at which the menu should be shown.
        Use wxWindow::ScreenToClient to convert to client coordinates.

        You can also omit a position from  wxWindow::PopupMenu in order to use
        the current mouse pointer position.

        If the event originated from a keyboard event, the value returned from this
        function will be wxDefaultPosition.
    */
    const wxPoint& GetPosition() const;

    /**
        Sets the position at which the menu should be shown.
    */
    void SetPosition(const wxPoint& point);
};



/**
    @class wxEraseEvent

    An erase event is sent when a window's background needs to be repainted.

    On some platforms, such as GTK+, this event is simulated (simply generated just
    before the paint event) and may cause flicker. It is therefore recommended that
    you set the text background colour explicitly in order to prevent flicker.
    The default background colour under GTK+ is grey.

    To intercept this event, use the EVT_ERASE_BACKGROUND macro in an event table
    definition.

    You must use the device context returned by GetDC() to draw on, don't create
    a wxPaintDC in the event handler.

    @beginEventTable{wxEraseEvent}
    @event{EVT_ERASE_BACKGROUND(func)}
        Process a @c wxEVT_ERASE_BACKGROUND event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxEraseEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxEraseEvent(int id = 0, wxDC* dc = NULL);

    /**
        Returns the device context associated with the erase event to draw on.

        The returned pointer is never @NULL.
    */
    wxDC* GetDC() const;
};



/**
    @class wxFocusEvent

    A focus event is sent when a window's focus changes. The window losing focus
    receives a "kill focus" event while the window gaining it gets a "set focus" one.

    Notice that the set focus event happens both when the user gives focus to the
    window (whether using the mouse or keyboard) and when it is done from the
    program itself using wxWindow::SetFocus.

    The focus event handlers should almost invariably call wxEvent::Skip() on
    their event argument to allow the default handling to take place. Failure
    to do this may result in incorrect behaviour of the native controls. Also
    note that wxEVT_KILL_FOCUS handler must not call wxWindow::SetFocus() as
    this, again, is not supported by all native controls. If you need to do
    this, consider using the @ref sec_delayed_action described in wxIdleEvent
    documentation.

    @beginEventTable{wxFocusEvent}
    @event{EVT_SET_FOCUS(func)}
        Process a @c wxEVT_SET_FOCUS event.
    @event{EVT_KILL_FOCUS(func)}
        Process a @c wxEVT_KILL_FOCUS event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxFocusEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxFocusEvent(wxEventType eventType = wxEVT_NULL, int id = 0);

    /**
        Returns the window associated with this event, that is the window which had the
        focus before for the @c wxEVT_SET_FOCUS event and the window which is
        going to receive focus for the @c wxEVT_KILL_FOCUS one.

        Warning: the window pointer may be @NULL!
    */
    wxWindow *GetWindow() const;

    void SetWindow(wxWindow *win);
};



/**
    @class wxChildFocusEvent

    A child focus event is sent to a (parent-)window when one of its child windows
    gains focus, so that the window could restore the focus back to its corresponding
    child if it loses it now and regains later.

    Notice that child window is the direct child of the window receiving event.
    Use wxWindow::FindFocus() to retrieve the window which is actually getting focus.

    @beginEventTable{wxChildFocusEvent}
    @event{EVT_CHILD_FOCUS(func)}
        Process a @c wxEVT_CHILD_FOCUS event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxChildFocusEvent : public wxCommandEvent
{
public:
    /**
        Constructor.

        @param win
            The direct child which is (or which contains the window which is) receiving
            the focus.
    */
    wxChildFocusEvent(wxWindow* win = NULL);

    /**
        Returns the direct child which receives the focus, or a (grand-)parent of the
        control receiving the focus.

        To get the actually focused control use wxWindow::FindFocus.
    */
    wxWindow *GetWindow() const;
};



/**
    @class wxMouseCaptureLostEvent

    A mouse capture lost event is sent to a window that had obtained mouse capture,
    which was subsequently lost due to an "external" event (for example, when a dialog
    box is shown or if another application captures the mouse).

    If this happens, this event is sent to all windows that are on the capture stack
    (i.e. called CaptureMouse, but didn't call ReleaseMouse yet). The event is
    not sent if the capture changes because of a call to CaptureMouse or
    ReleaseMouse.

    This event is currently emitted under Windows only.

    @beginEventTable{wxMouseCaptureLostEvent}
    @event{EVT_MOUSE_CAPTURE_LOST(func)}
        Process a @c wxEVT_MOUSE_CAPTURE_LOST event.
    @endEventTable

    @onlyfor{wxmsw}

    @library{wxcore}
    @category{events}

    @see wxMouseCaptureChangedEvent, @ref overview_events,
         wxWindow::CaptureMouse, wxWindow::ReleaseMouse, wxWindow::GetCapture
*/
class wxMouseCaptureLostEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxMouseCaptureLostEvent(wxWindowID windowId = 0);
};



class wxDisplayChangedEvent : public wxEvent
{
public:
    wxDisplayChangedEvent();
};


class wxPaletteChangedEvent : public wxEvent
{
public:
    wxPaletteChangedEvent(wxWindowID winid = 0);

    void SetChangedWindow(wxWindow* win);
    wxWindow* GetChangedWindow() const;
};


class wxQueryNewPaletteEvent : public wxEvent
{
public:
    wxQueryNewPaletteEvent(wxWindowID winid = 0);
    
    void SetPaletteRealized(bool realized);
    bool GetPaletteRealized();
};




/**
    @class wxNotifyEvent

    This class is not used by the event handlers by itself, but is a base class
    for other event classes (such as wxBookCtrlEvent).

    It (or an object of a derived class) is sent when the controls state is being
    changed and allows the program to wxNotifyEvent::Veto() this change if it wants
    to prevent it from happening.

    @library{wxcore}
    @category{events}

    @see wxBookCtrlEvent
*/
class wxNotifyEvent : public wxCommandEvent
{
public:
    /**
        Constructor (used internally by wxWidgets only).
    */
    wxNotifyEvent(wxEventType eventType = wxEVT_NULL, int id = 0);

    /**
        This is the opposite of Veto(): it explicitly allows the event to be processed.
        For most events it is not necessary to call this method as the events are allowed
        anyhow but some are forbidden by default (this will be mentioned in the corresponding
        event description).
    */
    void Allow();

    /**
        Returns @true if the change is allowed (Veto() hasn't been called) or @false
        otherwise (if it was).
    */
    bool IsAllowed() const;

    /**
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for vetoing
        the change because otherwise the applications behaviour (which just refuses to
        do what the user wants) might be quite surprising.
    */
    void Veto();
};


/**
    @class wxThreadEvent

    This class adds some simple functionality to wxEvent to facilitate
    inter-thread communication.

    This event is not natively emitted by any control/class: it is just
    a helper class for the user.
    Its most important feature is the GetEventCategory() implementation which
    allows thread events @b NOT to be processed by wxEventLoopBase::YieldFor calls
    (unless the @c wxEVT_CATEGORY_THREAD is specified - which is never in wx code).

    @library{wxcore}
    @category{events,threading}

    @see @ref overview_thread, wxEventLoopBase::YieldFor

    @since 2.9.0
*/
class wxThreadEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxThreadEvent(wxEventType eventType = wxEVT_THREAD, int id = wxID_ANY);

    /**
        Clones this event making sure that all internal members which use
        COW (only @c m_commandString for now; see @ref overview_refcount)
        are unshared (see wxObject::UnShare).
    */
    virtual wxEvent *Clone() const;

    /**
        Returns @c wxEVT_CATEGORY_THREAD.

        This is important to avoid unwanted processing of thread events
        when calling wxEventLoopBase::YieldFor().
    */
    virtual wxEventCategory GetEventCategory() const;

    /**
        Sets custom data payload.

        The @a payload argument may be of any type that wxAny can handle
        (i.e. pretty much anything). Note that T's copy constructor must be
        thread-safe, i.e. create a copy that doesn't share anything with
        the original (see Clone()).

        @note This method is not available with Visual C++ 6.

        @since 2.9.1

        @see GetPayload(), wxAny
     */
    template<typename T>
    void SetPayload(const T& payload);

    /**
        Get custom data payload.

        Correct type is checked in debug builds.

        @note This method is not available with Visual C++ 6.

        @since 2.9.1

        @see SetPayload(), wxAny
     */
    template<typename T>
    T GetPayload() const;

    /**
        Returns extra information integer value.
    */
    long GetExtraLong() const;

    /**
        Returns stored integer value.
    */
    int GetInt() const;

    /**
        Returns stored string value.
    */
    wxString GetString() const;


    /**
        Sets the extra information value.
    */
    void SetExtraLong(long extraLong);

    /**
        Sets the integer value.
    */
    void SetInt(int intCommand);

    /**
        Sets the string value.
    */
    void SetString(const wxString& string);
};


/**
    @class wxHelpEvent

    A help event is sent when the user has requested context-sensitive help.
    This can either be caused by the application requesting context-sensitive help mode
    via wxContextHelp, or (on MS Windows) by the system generating a WM_HELP message when
    the user pressed F1 or clicked on the query button in a dialog caption.

    A help event is sent to the window that the user clicked on, and is propagated
    up the window hierarchy until the event is processed or there are no more event
    handlers.

    The application should call wxEvent::GetId to check the identity of the
    clicked-on window, and then either show some suitable help or call wxEvent::Skip()
    if the identifier is unrecognised.

    Calling Skip is important because it allows wxWidgets to generate further
    events for ancestors of the clicked-on window. Otherwise it would be impossible to
    show help for container windows, since processing would stop after the first window
    found.

    @beginEventTable{wxHelpEvent}
    @event{EVT_HELP(id, func)}
        Process a @c wxEVT_HELP event.
    @event{EVT_HELP_RANGE(id1, id2, func)}
        Process a @c wxEVT_HELP event for a range of ids.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxContextHelp, wxDialog, @ref overview_events
*/
class wxHelpEvent : public wxCommandEvent
{
public:
    /**
        Indicates how a wxHelpEvent was generated.
    */
    enum Origin
    {
        Origin_Unknown,    /**< unrecognized event source. */
        Origin_Keyboard,   /**< event generated from F1 key press. */

        /** event generated by wxContextHelp or from the [?] button on
            the title bar (Windows). */
        Origin_HelpButton
    };

    /**
        Constructor.
    */
    wxHelpEvent(wxEventType type = wxEVT_NULL,
                wxWindowID winid = 0,
                const wxPoint& pt = wxDefaultPosition,
                wxHelpEvent::Origin origin = Origin_Unknown);

    /**
        Returns the origin of the help event which is one of the ::wxHelpEventOrigin
        values.

        The application may handle events generated using the keyboard or mouse
        differently, e.g. by using wxGetMousePosition() for the mouse events.

        @see SetOrigin()
    */
    wxHelpEvent::Origin GetOrigin() const;

    /**
        Returns the left-click position of the mouse, in screen coordinates.
        This allows the application to position the help appropriately.
    */
    const wxPoint& GetPosition() const;

    /**
        Set the help event origin, only used internally by wxWidgets normally.

        @see GetOrigin()
    */
    void SetOrigin(wxHelpEvent::Origin origin);

    /**
        Sets the left-click position of the mouse, in screen coordinates.
    */
    void SetPosition(const wxPoint& pt);
};



/**
    @class wxScrollEvent

    A scroll event holds information about events sent from stand-alone
    scrollbars (see wxScrollBar) and sliders (see wxSlider).

    Note that scrolled windows send the wxScrollWinEvent which does not derive from
    wxCommandEvent, but from wxEvent directly - don't confuse these two kinds of
    events and use the event table macros mentioned below only for the scrollbar-like
    controls.

    @section scrollevent_diff The difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_CHANGED

    The EVT_SCROLL_THUMBRELEASE event is only emitted when actually dragging the thumb
    using the mouse and releasing it (This EVT_SCROLL_THUMBRELEASE event is also followed
    by an EVT_SCROLL_CHANGED event).

    The EVT_SCROLL_CHANGED event also occurs when using the keyboard to change the thumb
    position, and when clicking next to the thumb (In all these cases the EVT_SCROLL_THUMBRELEASE
    event does not happen).

    In short, the EVT_SCROLL_CHANGED event is triggered when scrolling/ moving has finished
    independently of the way it had started. Please see the widgets sample ("Slider" page)
    to see the difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_CHANGED in action.

    @remarks
    Note that unless specifying a scroll control identifier, you will need to test for scrollbar
    orientation with wxScrollEvent::GetOrientation, since horizontal and vertical scroll events
    are processed using the same event handler.

    @beginEventTable{wxScrollEvent}
    You can use EVT_COMMAND_SCROLL... macros with window IDs for when intercepting
    scroll events from controls, or EVT_SCROLL... macros without window IDs for
    intercepting scroll events from the receiving window -- except for this, the
    macros behave exactly the same.
    @event{EVT_SCROLL(func)}
        Process all scroll events.
    @event{EVT_SCROLL_TOP(func)}
        Process @c wxEVT_SCROLL_TOP scroll-to-top events (minimum position).
    @event{EVT_SCROLL_BOTTOM(func)}
        Process @c wxEVT_SCROLL_BOTTOM scroll-to-bottom events (maximum position).
    @event{EVT_SCROLL_LINEUP(func)}
        Process @c wxEVT_SCROLL_LINEUP line up events.
    @event{EVT_SCROLL_LINEDOWN(func)}
        Process @c wxEVT_SCROLL_LINEDOWN line down events.
    @event{EVT_SCROLL_PAGEUP(func)}
        Process @c wxEVT_SCROLL_PAGEUP page up events.
    @event{EVT_SCROLL_PAGEDOWN(func)}
        Process @c wxEVT_SCROLL_PAGEDOWN page down events.
    @event{EVT_SCROLL_THUMBTRACK(func)}
        Process @c wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the
        user drags the thumbtrack).
    @event{EVT_SCROLL_THUMBRELEASE(func)}
        Process @c wxEVT_SCROLL_THUMBRELEASE thumb release events.
    @event{EVT_SCROLL_CHANGED(func)}
        Process @c wxEVT_SCROLL_CHANGED end of scrolling events (MSW only).
    @event{EVT_COMMAND_SCROLL(id, func)}
        Process all scroll events.
    @event{EVT_COMMAND_SCROLL_TOP(id, func)}
        Process @c wxEVT_SCROLL_TOP scroll-to-top events (minimum position).
    @event{EVT_COMMAND_SCROLL_BOTTOM(id, func)}
        Process @c wxEVT_SCROLL_BOTTOM scroll-to-bottom events (maximum position).
    @event{EVT_COMMAND_SCROLL_LINEUP(id, func)}
        Process @c wxEVT_SCROLL_LINEUP line up events.
    @event{EVT_COMMAND_SCROLL_LINEDOWN(id, func)}
        Process @c wxEVT_SCROLL_LINEDOWN line down events.
    @event{EVT_COMMAND_SCROLL_PAGEUP(id, func)}
        Process @c wxEVT_SCROLL_PAGEUP page up events.
    @event{EVT_COMMAND_SCROLL_PAGEDOWN(id, func)}
        Process @c wxEVT_SCROLL_PAGEDOWN page down events.
    @event{EVT_COMMAND_SCROLL_THUMBTRACK(id, func)}
        Process @c wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent
        as the user drags the thumbtrack).
    @event{EVT_COMMAND_SCROLL_THUMBRELEASE(func)}
        Process @c wxEVT_SCROLL_THUMBRELEASE thumb release events.
    @event{EVT_COMMAND_SCROLL_CHANGED(func)}
        Process @c wxEVT_SCROLL_CHANGED end of scrolling events (MSW only).
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxScrollBar, wxSlider, wxSpinButton, wxScrollWinEvent, @ref overview_events
*/
class wxScrollEvent : public wxCommandEvent
{
public:
    /**
        Constructor.
    */
    wxScrollEvent(wxEventType commandType = wxEVT_NULL, int id = 0, int pos = 0,
                  int orientation = 0);

    /**
        Returns wxHORIZONTAL or wxVERTICAL, depending on the orientation of the
        scrollbar.
    */
    int GetOrientation() const;

    /**
        Returns the position of the scrollbar.
    */
    int GetPosition() const;

    
    void SetOrientation(int orient);
    void SetPosition(int pos);    
};




/**
    @class wxInitDialogEvent

    A wxInitDialogEvent is sent as a dialog or panel is being initialised.
    Handlers for this event can transfer data to the window.

    The default handler calls wxWindow::TransferDataToWindow.

    @beginEventTable{wxInitDialogEvent}
    @event{EVT_INIT_DIALOG(func)}
        Process a @c wxEVT_INIT_DIALOG event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events
*/
class wxInitDialogEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxInitDialogEvent(int id = 0);
};



/**
    @class wxWindowDestroyEvent

    This event is sent as early as possible during the window destruction
    process.

    For the top level windows, as early as possible means that this is done by
    wxFrame or wxDialog destructor, i.e. after the destructor of the derived
    class was executed and so any methods specific to the derived class can't
    be called any more from this event handler. If you need to do this, you
    must call wxWindow::SendDestroyEvent() from your derived class destructor.

    For the child windows, this event is generated just before deleting the
    window from wxWindow::Destroy() (which is also called when the parent
    window is deleted) or from the window destructor if operator @c delete was
    used directly (which is not recommended for this very reason).

    It is usually pointless to handle this event in the window itself but it ca
    be very useful to receive notifications about the window destruction in the
    parent window or in any other object interested in this window.

    @library{wxcore}
    @category{events}

    @see @ref overview_events, wxWindowCreateEvent
*/
class wxWindowDestroyEvent : public wxCommandEvent
{
public:
    /**
        Constructor.
    */
    wxWindowDestroyEvent(wxWindow* win = NULL);

    /// Return the window being destroyed.
    wxWindow *GetWindow() const;
};


/**
    @class wxNavigationKeyEvent

    This event class contains information about navigation events,
    generated by navigation keys such as tab and page down.

    This event is mainly used by wxWidgets implementations.
    A wxNavigationKeyEvent handler is automatically provided by wxWidgets
    when you enable keyboard navigation inside a window by inheriting it from
    wxNavigationEnabled<>.

    @beginEventTable{wxNavigationKeyEvent}
    @event{EVT_NAVIGATION_KEY(func)}
        Process a navigation key event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxWindow::Navigate, wxWindow::NavigateIn
*/
class wxNavigationKeyEvent : public wxEvent
{
public:
    /**
        Flags which can be used with wxNavigationKeyEvent.
    */
    enum wxNavigationKeyEventFlags
    {
        IsBackward = 0x0000,
        IsForward = 0x0001,
        WinChange = 0x0002,
        FromTab = 0x0004
    };

    wxNavigationKeyEvent();
    wxNavigationKeyEvent(const wxNavigationKeyEvent& event);

    /**
        Returns the child that has the focus, or @NULL.
    */
    wxWindow* GetCurrentFocus() const;

    /**
        Returns @true if the navigation was in the forward direction.
    */
    bool GetDirection() const;

    /**
        Returns @true if the navigation event was from a tab key.
        This is required for proper navigation over radio buttons.
    */
    bool IsFromTab() const;

    /**
        Returns @true if the navigation event represents a window change
        (for example, from Ctrl-Page Down in a notebook).
    */
    bool IsWindowChange() const;

    /**
        Sets the current focus window member.
    */
    void SetCurrentFocus(wxWindow* currentFocus);

    /**
        Sets the direction to forward if @a direction is @true, or backward
        if @false.
    */
    void SetDirection(bool direction);

    /**
        Sets the flags for this event.
        The @a flags can be a combination of the ::wxNavigationKeyEventFlags values.
    */
    void SetFlags(long flags);

    /**
        Marks the navigation event as from a tab key.
    */
    void SetFromTab(bool fromTab);

    /**
        Marks the event as a window change event.
    */
    void SetWindowChange(bool windowChange);
};



/**
    @class wxMouseCaptureChangedEvent

    An mouse capture changed event is sent to a window that loses its
    mouse capture. This is called even if wxWindow::ReleaseMouse
    was called by the application code. Handling this event allows
    an application to cater for unexpected capture releases which
    might otherwise confuse mouse handling code.

    @onlyfor{wxmsw}

    @beginEventTable{wxMouseCaptureChangedEvent}
    @event{EVT_MOUSE_CAPTURE_CHANGED(func)}
        Process a @c wxEVT_MOUSE_CAPTURE_CHANGED event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxMouseCaptureLostEvent, @ref overview_events,
         wxWindow::CaptureMouse, wxWindow::ReleaseMouse, wxWindow::GetCapture
*/
class wxMouseCaptureChangedEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxMouseCaptureChangedEvent(wxWindowID windowId = 0,
                               wxWindow* gainedCapture = NULL);

    /**
        Returns the window that gained the capture, or @NULL if it was a
        non-wxWidgets window.
    */
    wxWindow* GetCapturedWindow() const;
};



/**
    @class wxCloseEvent

    This event class contains information about window and session close events.

    The handler function for EVT_CLOSE is called when the user has tried to close a
    a frame or dialog box using the window manager (X) or system menu (Windows).
    It can also be invoked by the application itself programmatically, for example by
    calling the wxWindow::Close function.

    You should check whether the application is forcing the deletion of the window
    using wxCloseEvent::CanVeto. If this is @false, you @e must destroy the window
    using wxWindow::Destroy.

    If the return value is @true, it is up to you whether you respond by destroying
    the window.

    If you don't destroy the window, you should call wxCloseEvent::Veto to
    let the calling code know that you did not destroy the window.
    This allows the wxWindow::Close function to return @true or @false depending
    on whether the close instruction was honoured or not.

    Example of a wxCloseEvent handler:

    @code
        void MyFrame::OnClose(wxCloseEvent& event)
        {
            if ( event.CanVeto() && m_bFileNotSaved )
            {
                if ( wxMessageBox("The file has not been saved... continue closing?",
                                  "Please confirm",
                                  wxICON_QUESTION | wxYES_NO) != wxYES )
                {
                    event.Veto();
                    return;
                }
            }

            Destroy();  // you may also do:  event.Skip();
                        // since the default event handler does call Destroy(), too
        }
    @endcode

    The EVT_END_SESSION event is slightly different as it is sent by the system
    when the user session is ending (e.g. because of log out or shutdown) and
    so all windows are being forcefully closed. At least under MSW, after the
    handler for this event is executed the program is simply killed by the
    system. Because of this, the default handler for this event provided by
    wxWidgets calls all the usual cleanup code (including wxApp::OnExit()) so
    that it could still be executed and exit()s the process itself, without
    waiting for being killed. If this behaviour is for some reason undesirable,
    make sure that you define a handler for this event in your wxApp-derived
    class and do not call @c event.Skip() in it (but be aware that the system
    will still kill your application).

    @beginEventTable{wxCloseEvent}
    @event{EVT_CLOSE(func)}
        Process a @c wxEVT_CLOSE_WINDOW command event, supplying the member function.
        This event applies to wxFrame and wxDialog classes.
    @event{EVT_QUERY_END_SESSION(func)}
        Process a @c wxEVT_QUERY_END_SESSION session event, supplying the member function.
        This event can be handled in wxApp-derived class only.
    @event{EVT_END_SESSION(func)}
        Process a @c wxEVT_END_SESSION session event, supplying the member function.
        This event can be handled in wxApp-derived class only.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxWindow::Close, @ref overview_windowdeletion
*/
class wxCloseEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxCloseEvent(wxEventType commandEventType = wxEVT_NULL, int id = 0);

    /**
        Returns @true if you can veto a system shutdown or a window close event.
        Vetoing a window close event is not possible if the calling code wishes to
        force the application to exit, and so this function must be called to check this.
    */
    bool CanVeto() const;

    /**
        Returns @true if the user is just logging off or @false if the system is
        shutting down. This method can only be called for end session and query end
        session events, it doesn't make sense for close window event.
    */
    bool GetLoggingOff() const;

    /**
        Sets the 'can veto' flag.
    */
    void SetCanVeto(bool canVeto);

    /**
        Sets the 'logging off' flag.
    */
    void SetLoggingOff(bool loggingOff);

    /**
        Call this from your event handler to veto a system shutdown or to signal
        to the calling application that a window close did not happen.

        You can only veto a shutdown if CanVeto() returns @true.
    */
    void Veto(bool veto = true);
};



/**
    @class wxMenuEvent

    This class is used for a variety of menu-related events. Note that
    these do not include menu command events, which are
    handled using wxCommandEvent objects.

    The default handler for @c wxEVT_MENU_HIGHLIGHT displays help
    text in the first field of the status bar.

    @beginEventTable{wxMenuEvent}
    @event{EVT_MENU_OPEN(func)}
        A menu is about to be opened. On Windows, this is only sent once for each
        navigation of the menubar (up until all menus have closed).
    @event{EVT_MENU_CLOSE(func)}
        A menu has been just closed.
    @event{EVT_MENU_HIGHLIGHT(id, func)}
        The menu item with the specified id has been highlighted: used to show
        help prompts in the status bar by wxFrame
    @event{EVT_MENU_HIGHLIGHT_ALL(func)}
        A menu item has been highlighted, i.e. the currently selected menu item has changed.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxCommandEvent, @ref overview_events
*/
class wxMenuEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxMenuEvent(wxEventType type = wxEVT_NULL, int id = 0, wxMenu* menu = NULL);

    /**
        Returns the menu which is being opened or closed.

        This method can only be used with the @c OPEN and @c CLOSE events.

        The returned value is never @NULL in the ports implementing this
        function, which currently includes all the major ones.
    */
    wxMenu* GetMenu() const;

    /**
        Returns the menu identifier associated with the event.
        This method should be only used with the @c HIGHLIGHT events.
    */
    int GetMenuId() const;

    /**
        Returns @true if the menu which is being opened or closed is a popup menu,
        @false if it is a normal one.

        This method should only be used with the @c OPEN and @c CLOSE events.
    */
    bool IsPopup() const;
};

/**
    @class wxShowEvent

    An event being sent when the window is shown or hidden.
    The event is triggered by calls to wxWindow::Show(), and any user
    action showing a previously hidden window or vice versa (if allowed by
    the current platform and/or window manager).
    Notice that the event is not triggered when the application is iconized
    (minimized) or restored under wxMSW.

    @onlyfor{wxmsw,wxgtk,wxos2}

    @beginEventTable{wxShowEvent}
    @event{EVT_SHOW(func)}
        Process a @c wxEVT_SHOW event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events, wxWindow::Show,
         wxWindow::IsShown
*/

class wxShowEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxShowEvent(int winid = 0, bool show = false);

    /**
        Set whether the windows was shown or hidden.
    */
    void SetShow(bool show);

    /**
        Return @true if the window has been shown, @false if it has been
        hidden.
    */
    bool IsShown() const;

    /**
        @deprecated This function is deprecated in favour of IsShown().
    */
    bool GetShow() const;
};



/**
    @class wxIconizeEvent

    An event being sent when the frame is iconized (minimized) or restored.

    Currently only wxMSW and wxGTK generate such events.

    @onlyfor{wxmsw,wxgtk}

    @beginEventTable{wxIconizeEvent}
    @event{EVT_ICONIZE(func)}
        Process a @c wxEVT_ICONIZE event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see @ref overview_events, wxTopLevelWindow::Iconize,
         wxTopLevelWindow::IsIconized
*/
class wxIconizeEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxIconizeEvent(int id = 0, bool iconized = true);

    /**
        Returns @true if the frame has been iconized, @false if it has been
        restored.
    */
    bool IsIconized() const;

    /**
        @deprecated This function is deprecated in favour of IsIconized().
    */
    bool Iconized() const;
};



/**
    @class wxMoveEvent

    A move event holds information about wxTopLevelWindow move change events.

    These events are currently only generated by wxMSW port.

    @beginEventTable{wxMoveEvent}
    @event{EVT_MOVE(func)}
        Process a @c wxEVT_MOVE event, which is generated when a window is moved.
    @event{EVT_MOVE_START(func)}
        Process a @c wxEVT_MOVE_START event, which is generated when the user starts
        to move or size a window. wxMSW only.
    @event{EVT_MOVING(func)}
        Process a @c wxEVT_MOVING event, which is generated while the user is
        moving the window. wxMSW only.
    @event{EVT_MOVE_END(func)}
        Process a @c wxEVT_MOVE_END event, which is generated when the user stops
        moving or sizing a window. wxMSW only.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxPoint, @ref overview_events
*/
class wxMoveEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxMoveEvent(const wxPoint& pt, int id = 0);

    /**
        Returns the position of the window generating the move change event.
    */
    wxPoint GetPosition() const;

    wxRect GetRect() const;
    void SetRect(const wxRect& rect);
    void SetPosition(const wxPoint& pos);    
};


/**
    @class wxSizeEvent

    A size event holds information about size change events of wxWindow.

    The EVT_SIZE handler function will be called when the window has been resized.

    You may wish to use this for frames to resize their child windows as appropriate.

    Note that the size passed is of the whole window: call wxWindow::GetClientSize()
    for the area which may be used by the application.

    When a window is resized, usually only a small part of the window is damaged
    and you  may only need to repaint that area. However, if your drawing depends on the
    size of the window, you may need to clear the DC explicitly and repaint the whole window.
    In which case, you may need to call wxWindow::Refresh to invalidate the entire window.

    @b Important : Sizers ( see @ref overview_sizer ) rely on size events to function
    correctly. Therefore, in a sizer-based layout, do not forget to call Skip on all
    size events you catch (and don't catch size events at all when you don't need to).
 
    @beginEventTable{wxSizeEvent}
    @event{EVT_SIZE(func)}
        Process a @c wxEVT_SIZE event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see wxSize, @ref overview_events
*/
class wxSizeEvent : public wxEvent
{
public:
    /**
        Constructor.
    */
    wxSizeEvent(const wxSize& sz, int id = 0);

    /**
        Returns the entire size of the window generating the size change event.

        This is the new total size of the window, i.e. the same size as would
        be returned by wxWindow::GetSize() if it were called now. Use
        wxWindow::GetClientSize() if you catch this event in a top level window
        such as wxFrame to find the size available for the window contents.
    */
    wxSize GetSize() const;
    void SetSize(wxSize size);

    wxRect GetRect() const;
    void SetRect(wxRect rect);
};



/**
    @class wxSetCursorEvent

    A wxSetCursorEvent is generated from wxWindow when the mouse cursor is about
    to be set as a result of mouse motion.

    This event gives the application the chance to perform specific mouse cursor
    processing based on the current position of the mouse within the window.
    Use wxSetCursorEvent::SetCursor to specify the cursor you want to be displayed.

    @beginEventTable{wxSetCursorEvent}
    @event{EVT_SET_CURSOR(func)}
        Process a @c wxEVT_SET_CURSOR event.
    @endEventTable

    @library{wxcore}
    @category{events}

    @see ::wxSetCursor, wxWindow::wxSetCursor
*/
class wxSetCursorEvent : public wxEvent
{
public:
    /**
        Constructor, used by the library itself internally to initialize the event
        object.
    */
    wxSetCursorEvent(wxCoord x = 0, wxCoord y = 0);

    /**
        Returns a reference to the cursor specified by this event.
    */
    const wxCursor& GetCursor() const;

    /**
        Returns the X coordinate of the mouse in client coordinates.
    */
    wxCoord GetX() const;

    /**
        Returns the Y coordinate of the mouse in client coordinates.
    */
    wxCoord GetY() const;

    /**
        Returns @true if the cursor specified by this event is a valid cursor.

        @remarks You cannot specify wxNullCursor with this event, as it is not
                 considered a valid cursor.
    */
    bool HasCursor() const;

    /**
        Sets the cursor associated with this event.
    */
    void SetCursor(const wxCursor& cursor);
};



// ============================================================================
// Global functions/macros
// ============================================================================

/** @addtogroup group_funcmacro_events */
//@{


wxEventType wxEVT_COMMAND_BUTTON_CLICKED;
wxEventType wxEVT_COMMAND_CHECKBOX_CLICKED;
wxEventType wxEVT_COMMAND_CHOICE_SELECTED;
wxEventType wxEVT_COMMAND_LISTBOX_SELECTED;
wxEventType wxEVT_COMMAND_LISTBOX_DOUBLECLICKED;
wxEventType wxEVT_COMMAND_CHECKLISTBOX_TOGGLED;
wxEventType wxEVT_COMMAND_MENU_SELECTED;
wxEventType wxEVT_COMMAND_SLIDER_UPDATED;
wxEventType wxEVT_COMMAND_RADIOBOX_SELECTED;
wxEventType wxEVT_COMMAND_RADIOBUTTON_SELECTED;
wxEventType wxEVT_COMMAND_SCROLLBAR_UPDATED;
wxEventType wxEVT_COMMAND_VLBOX_SELECTED;
wxEventType wxEVT_COMMAND_COMBOBOX_SELECTED;
wxEventType wxEVT_COMMAND_TOOL_RCLICKED;
wxEventType wxEVT_COMMAND_TOOL_DROPDOWN_CLICKED;
wxEventType wxEVT_COMMAND_TOOL_ENTER;
wxEventType wxEVT_COMMAND_COMBOBOX_DROPDOWN;
wxEventType wxEVT_COMMAND_COMBOBOX_CLOSEUP;
wxEventType wxEVT_THREAD;
wxEventType wxEVT_LEFT_DOWN;
wxEventType wxEVT_LEFT_UP;
wxEventType wxEVT_MIDDLE_DOWN;
wxEventType wxEVT_MIDDLE_UP;
wxEventType wxEVT_RIGHT_DOWN;
wxEventType wxEVT_RIGHT_UP;
wxEventType wxEVT_MOTION;
wxEventType wxEVT_ENTER_WINDOW;
wxEventType wxEVT_LEAVE_WINDOW;
wxEventType wxEVT_LEFT_DCLICK;
wxEventType wxEVT_MIDDLE_DCLICK;
wxEventType wxEVT_RIGHT_DCLICK;
wxEventType wxEVT_SET_FOCUS;
wxEventType wxEVT_KILL_FOCUS;
wxEventType wxEVT_CHILD_FOCUS;
wxEventType wxEVT_MOUSEWHEEL;
wxEventType wxEVT_AUX1_DOWN;
wxEventType wxEVT_AUX1_UP;
wxEventType wxEVT_AUX1_DCLICK;
wxEventType wxEVT_AUX2_DOWN;
wxEventType wxEVT_AUX2_UP;
wxEventType wxEVT_AUX2_DCLICK;
wxEventType wxEVT_CHAR;
wxEventType wxEVT_CHAR_HOOK;
wxEventType wxEVT_NAVIGATION_KEY;
wxEventType wxEVT_KEY_DOWN;
wxEventType wxEVT_KEY_UP;
wxEventType wxEVT_HOTKEY;
wxEventType wxEVT_SET_CURSOR;
wxEventType wxEVT_SCROLL_TOP;
wxEventType wxEVT_SCROLL_BOTTOM;
wxEventType wxEVT_SCROLL_LINEUP;
wxEventType wxEVT_SCROLL_LINEDOWN;
wxEventType wxEVT_SCROLL_PAGEUP;
wxEventType wxEVT_SCROLL_PAGEDOWN;
wxEventType wxEVT_SCROLL_THUMBTRACK;
wxEventType wxEVT_SCROLL_THUMBRELEASE;
wxEventType wxEVT_SCROLL_CHANGED;
wxEventType wxEVT_SPIN_UP;
wxEventType wxEVT_SPIN_DOWN;
wxEventType wxEVT_SPIN;
wxEventType wxEVT_SCROLLWIN_TOP;
wxEventType wxEVT_SCROLLWIN_BOTTOM;
wxEventType wxEVT_SCROLLWIN_LINEUP;
wxEventType wxEVT_SCROLLWIN_LINEDOWN;
wxEventType wxEVT_SCROLLWIN_PAGEUP;
wxEventType wxEVT_SCROLLWIN_PAGEDOWN;
wxEventType wxEVT_SCROLLWIN_THUMBTRACK;
wxEventType wxEVT_SCROLLWIN_THUMBRELEASE;
wxEventType wxEVT_SIZE;
wxEventType wxEVT_MOVE;
wxEventType wxEVT_CLOSE_WINDOW;
wxEventType wxEVT_END_SESSION;
wxEventType wxEVT_QUERY_END_SESSION;
wxEventType wxEVT_ACTIVATE_APP;
wxEventType wxEVT_ACTIVATE;
wxEventType wxEVT_CREATE;
wxEventType wxEVT_DESTROY;
wxEventType wxEVT_SHOW;
wxEventType wxEVT_ICONIZE;
wxEventType wxEVT_MAXIMIZE;
wxEventType wxEVT_MOUSE_CAPTURE_CHANGED;
wxEventType wxEVT_MOUSE_CAPTURE_LOST;
wxEventType wxEVT_PAINT;
wxEventType wxEVT_ERASE_BACKGROUND;
wxEventType wxEVT_NC_PAINT;
wxEventType wxEVT_MENU_OPEN;
wxEventType wxEVT_MENU_CLOSE;
wxEventType wxEVT_MENU_HIGHLIGHT;
wxEventType wxEVT_CONTEXT_MENU;
wxEventType wxEVT_SYS_COLOUR_CHANGED;
wxEventType wxEVT_DISPLAY_CHANGED;
wxEventType wxEVT_QUERY_NEW_PALETTE;
wxEventType wxEVT_PALETTE_CHANGED;
wxEventType wxEVT_JOY_BUTTON_DOWN;
wxEventType wxEVT_JOY_BUTTON_UP;
wxEventType wxEVT_JOY_MOVE;
wxEventType wxEVT_JOY_ZMOVE;
wxEventType wxEVT_DROP_FILES;
wxEventType wxEVT_INIT_DIALOG;
wxEventType wxEVT_IDLE;
wxEventType wxEVT_UPDATE_UI;
wxEventType wxEVT_SIZING;
wxEventType wxEVT_MOVING;
wxEventType wxEVT_MOVE_START;
wxEventType wxEVT_MOVE_END;
wxEventType wxEVT_HIBERNATE;
wxEventType wxEVT_COMMAND_TEXT_COPY;
wxEventType wxEVT_COMMAND_TEXT_CUT;
wxEventType wxEVT_COMMAND_TEXT_PASTE;
wxEventType wxEVT_COMMAND_LEFT_CLICK;
wxEventType wxEVT_COMMAND_LEFT_DCLICK;
wxEventType wxEVT_COMMAND_RIGHT_CLICK;
wxEventType wxEVT_COMMAND_RIGHT_DCLICK;
wxEventType wxEVT_COMMAND_SET_FOCUS;
wxEventType wxEVT_COMMAND_KILL_FOCUS;
wxEventType wxEVT_COMMAND_ENTER;
wxEventType wxEVT_HELP;
wxEventType wxEVT_DETAILED_HELP;
wxEventType wxEVT_COMMAND_TEXT_UPDATED;
wxEventType wxEVT_COMMAND_TEXT_ENTER;
wxEventType wxEVT_COMMAND_TOOL_CLICKED;
wxEventType wxEVT_WINDOW_MODAL_DIALOG_CLOSED;



//@}

